#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;
use Bio::Phylo::Util::Logger ':levels';
use Megatree;

# process command line arguments
my $verbosity = WARN;
my ( $infile, $dbfile );
GetOptions(
	'infile=s' => \$infile,
	'dbfile=s' => \$dbfile,
	'verbose+' => \$verbosity,
);
die "Usage: make_megatree -i <infile> [-d <dbfile>] [--verbose]\n" if not $infile;

# instantiate helper objects
my $log = Bio::Phylo::Util::Logger->new( '-level' => $verbosity, '-class' => 'main' );
my ( $sth, $megatree );
if ( $dbfile ) {
	$log->info("will insert megatree directly into db '$dbfile'");
	$megatree = Megatree->connect($dbfile);
	$dbh = $megatree->dbh;
	$sth = $dbh->prepare("insert into node(id,parent,name,length) values(?,?,?,?)");
}
else {
	$log->warn("no db file given, CSV output will be written to STDOUT");
}
my $idcounter = 2;
my %idcache;

# do the conversion
my $newick = slurp($infile);
my $labeled = label_nodes($newick);
if ( $labeled =~ /^(.+);$/ ) {
	my $clade = $1;
	$log->info("captured outer clade, going to traverse");
	traverse( $clade );
	if ( $megatree ) {
		$log->info("going to compute indexes");
		$megatree->get_root->_index;
	}
}
else {
	die "no ; in newick: $labeled";
}

# read the provided file into a string, strip line breaks
sub slurp {
	my $file = shift;
	$log->info("going to read file $file");
	open my $fh, '<', $file or die $!;
	my @lines = <$fh>;
	chomp @lines;
	return join '', @lines;
}

# attach new, unique labels to interior nodes
sub label_nodes {
	my $string = shift;

	# strip previously existing node labels
	$string =~ s/\)'[^']+'/\)/g;
	$string =~ s/\)[^:\),]+/\)/g;
	$string =~ s/\)$/e\)/; # add “e” near the end
	
	# apply new labels
	my @tokens = split ( /\)/, $string );
	my $line = '';
	my $counter = 1;
	for my $i ( 0 .. $#tokens ) {
		$line .= $tokens[$i] . ')n' . $counter++;
	}
	$line =~ s/e(\)n\d+)$/$1/; #remove “e”
	$line .= ';';

	return $line;
}

# recursively traverse megatree
sub traverse {
	my ( $tokens, $parent, %seen ) = @_;
	no warnings 'recursion';
	my $max = length($tokens) - 1;
	$log->debug("going to tokenize ".($max+1)." characters");
	
	# split tokens into clades, traverse
	my ( $depth, $label, $clade, @clades ) = ( 0, '', '' );
	for my $i ( 0 .. $max ) {
	
		# take a single character from the token string
		my $t = substr $tokens, $i, 1;
		
		# have completed a clade, store it
		if ( ( $t eq ',' ^ $t eq ')' ) && $depth == 1 ) {
			$log->debug("completed clade at token '$t', index $i");		
			push @clades, $clade;
			$clade = '';
		}
		
		# extending clade
		elsif ( $depth > 0 ) {
			$clade .= $t;
		}
		
		# at level zero, either the node label or at
		# beginning of token string
		elsif ( $depth == 0 && $t ne '(' ) {
			$label .= $t;
		}
		
		$depth++ if $t eq '(';
		$depth-- if $t eq ')';		
	}
	print_branch( $label, $parent ) unless $seen{$label}++;
	push @clades, $clade if $clade;
	$log->debug("going to recurse into ".scalar(@clades)." clades");
	traverse( $_, $label, %seen ) for @clades;
}

# print focal branch as CSV
sub print_branch {
	my ( $child, $parent ) = @_;
	if ( $parent ) {
		$parent =~ s/:.+//;	
		my $length = 0;
		if ( $child =~ /(.+?):(.+)/ ) {
			( $child, $length ) = ( $1, $2 );
		}
		$idcache{$child}  = $idcounter++ unless $idcache{$child};
		$idcache{$parent} = $idcounter++ unless $idcache{$parent};	
		doprint($idcache{$child},$idcache{$parent},$child,$length);
	}
	else {
		my $length = 0;
		if ( $child =~ /(.+?):(.+);\)/ ) {
			( $child, $length ) = ( $1, $2 );
		}		
		$idcache{$child} = $idcounter++ unless $idcache{$child};
		doprint($idcache{$child},1,$child,$length);
	}
}

sub doprint {
	my @values = @_;
	if ( $sth ) {
		$sth->execute(@values);
	}
	else {
		print join(',',@values), "\n";
	}
}