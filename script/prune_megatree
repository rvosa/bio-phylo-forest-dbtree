#!/usr/bin/perl
use strict;
use warnings;
use Megatree;
use Data::Dumper;
use Getopt::Long;
use Bio::Phylo::Util::Logger ':levels';

# autoflush STDOUT so writing isn't buffered
$|++;

# process command line arguments
my $verbosity = WARN;
my ( $infile, $dbfile, $tabular, $relabel, $list, $all, $keys );
GetOptions(
	'verbose+' => \$verbosity,
	'infile=s' => \$infile, 
	'dbfile=s' => \$dbfile, # sqlite file
	'list=s'   => \$list, # input is a comma-separated list
	'tabular'  => \$tabular, # output as adjacency table
	'relabel'  => \$relabel, # relabel internal nodes to /n\d+/
	'all'      => \$all, # keep all taxonomic levels, i.e. including unbranched internals
	'keys'     => \$keys, # inputs are primary keys, not names
);

# instantiate helper objects
my $intree   = Megatree->connect($dbfile);
my $log      = Bio::Phylo::Util::Logger->new(
	'-level' => $verbosity,
	'-class' => 'main',
);

# read input list, fetch nodes
my ( @nodes, %tree );
{

	# compose query depending on whether the inputs are primary keys or names
	my $query = sub {
		my $term = shift;
		if ( $keys ) {
			return $intree->_rs->find($term);
		}
		else {
			return $intree->_rs->single({ 'name' => $term });
		}
	};
	
	if ( $infile ) {
		$log->debug("going to read leaves to keep from $infile");
		open my $fh, '<', $infile or die $!;
		while(<$fh>) {
			chomp;
			my $name = $_;
		
			# skip blank lines
			if ( $name =~ /\S/ ) {
				if ( my $node = $query->($name) ) {
					push @nodes, $node;
					my $id = $node->id;
					$tree{$id} = {
						'id'     => $id,
						'parent' => $node->parent,
						'name'   => $node->name,
						'length' => $node->length,
						'node'   => 0,
					};
				}
				else {
					$log->warn("node '$name' not in tree");
				}
			}
		}
		$log->info("read ".scalar(@nodes)." leaves from $infile");
		close $fh;
	}
	elsif ( $list ) {
		for my $name ( split /,/, $list ) {
			if ( my $node = $query->($name) ) {
				push @nodes, $node;
				my $id = $node->id;
				$tree{$id} = {
					'id'     => $id,
					'parent' => $node->parent,
					'name'   => $node->name,
					'length' => $node->length,
					'node'   => 0,
				};
			}
			else {
				$log->warn("node '$name' not in tree");
			}		
		}
		$log->info("read ".scalar(@nodes)." leaves from $list");
	}
}

# use a queue to build the tree
{
	$log->debug("going to build subtree");
	while( @nodes ) {
		$log->debug( scalar(@nodes) . ' nodes to go' ) unless scalar(@nodes) % 1000;
		my $node = shift @nodes;

		# only continue building if focal node has a parent, i.e. is not the root
		if ( my $parent = $node->get_parent ) {
			my $pid = $parent->id;
			
			# only add the parent of the focal node once, to the tree (though it
			# would be clobbered in the hash anyway) and in the queue
			if ( not $tree{$pid} ) {
				$tree{$pid} = {
					'id'     => $pid,
					'parent' => $parent->parent,
					'name'   => ( $relabel ? "n$pid" : $parent->name ),
					'length' => ( $parent->length || 0 ),
					'node'   => 1,
				};
				push @nodes, $parent;
			}
		}
	}
	my @leaves = grep { !$_->{'node'} } values %tree;
	$log->debug("built subtree with ".scalar(@leaves)." leaves");
}

# remove unbranched internals
if ( not $all ) {
	$log->debug("going to remove unbranched internal nodes");
	my $deleted = 0;
	for my $node ( sort { $b->{'id'} <=> $a->{'id'} } grep { $_->{'node'} } values %tree ) {
		my $id = $node->{'id'};
		my @children = grep { $_->{'parent'} == $id } values %tree;
	
		# is unbranched internal
		if ( @children == 1 ) {
			$children[0]->{'parent'}  = $node->{'parent'};
			$children[0]->{'length'} += $node->{'length'};
			delete $tree{$id};
			$deleted++;
		}
	}
	$log->info("removed $deleted unbranched internal nodes");
}

# print the tree
{

	# print anything that we have, quit if unsuccessful
	$log->debug(Dumper(\%tree));
	if ( not %tree ) {
		$log->error("no tree was extracted, quitting");
		exit(1);
	}

	# print the tree as adjacency table
	if ( $tabular ) {
		print "child\tparent\tlength\n";
		for my $node ( sort { $a->{'id'} <=> $b->{'id'} } values %tree ) {
			print $node->{'name'}, "\t";
			if ( my $parent = $tree{ $node->{'parent'} } ) {
				print $parent->{'name'}, "\t";
			}
			else {
				print "\t"; # root
			}
			my $length = defined $node->{'length'} ? $node->{'length'} : '';
			print $length, "\n";
		}
	}

	# print the tree as newick
	else {
		no warnings 'recursion';
		my ($root) = sort { $a->{'id'} <=> $b->{'id'} } grep { $_->{'node'} } values %tree;
		to_newick($root);
		print ";\n";
	}
}

sub to_newick {
	my $node = shift;
	my $id = $node->{'id'};
	
	# the second clause is here because the NCBI taxonomy has the odd feature that the
	# parent ID of the root is the same as the ID of the root. Of course the root 
	# shouldn't have a parent ID at all, because it doesn't have a parent, but if
	# it does it certainly shouldn't be the same as itself, creating a cycle. #NCBILOL
	my @children = grep { $_->{'parent'} == $id && $_->{'id'} != $id } values %tree;
	if ( @children ) {
		print '(';
		for my $i ( 0 .. $#children ) {
			to_newick($children[$i]);
			print ',' if $i < $#children;
		}
		print ')';
	}
	if ( defined $node->{'length'} ) {
		print $node->{'name'}, ':', $node->{'length'};
	}
	else {
		print $node->{'name'};
	}
}